#pragma config(Sensor, dgtl1,  shaftEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           driveBackLeft, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topLeftIn,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           topRightOut,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           topRightIn,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           topLeftOut,    tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           clawLeft,      tmotorServoContinuousRotation, openLoop) //Positive is moving in, negative is moving out
#pragma config(Motor,  port7,           clawRight,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           driveFrontLeft, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           driveFrontRight, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          driveBackRight, tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
This code is the testing code for the team 25565B Robot for the 2016-2017 Starstruck competition
For competitions, use the file 2016-2017 Competition.c file, which has the autonomous and driver control structures
The robot was built by (last name alphabetical order, no favoritism):
- Nolan Flynn
- Ryan Garcia
- Ben Kaufman
- Justin Kretchman
- Dashiell Slamowitz
Code built by Nolan Flynn
This code was based on the Mecanum Drive - Basic.c Remote Control template file, included in the ROBOTC app

*/


//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Mecanum Drive - Basic
- This program allows you to remotely control a robot with mecanum wheels.
- The left joystick Y-axis controls the robot's forward and backward movement.
- The left joystick X-axis controls the robot's left and right movement.
- The right joystick X-axis controls the robot's rotation.

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        frontRight          VEX Motor             Front Right motor
Motor Port 3        backRight           VEX Motor             Back Right motor
Motor Port 4        frontLeft           VEX Motor             Front Left motor
Motor Port 5        backLeft            VEX Motor             Back Left motor
----------------------------------------------------------------------------------------------------*/

task main()
{
	SensorValue[shaftEncoder] = 0; //Calibrate the shaft encoder- must be in fully down position


	//Loop Forever
	while(1 == 1)
	{
		//Declaring variables- All variables can be changed from here, only modify other stuff if you need to add actual logic
		int armMotorPower = 90; //Arm moves up at 90 power
		int armMotorBoostPower = 90; //Arm moves up at 90 power above armPowerAngle
		int armMotorPowerDown = 70; //Arm moves down at 30 power

		int driveMotorPower = 110; //Drive power is 110 at maximum

		int armPowerAngle = 60; //Boost power activated, and claw closing when the arm is higher than 60 degrees from start

		int clawClampAngle = 40; //Claw starts clamping at 40 degrees
		int clawOpenAngle = 90; //Claw starts opening while throwing when the arm is higher than 90 degrees

		int clawPower = 80;

		int holdPower = 30;
		float frontMotorReductionFactor = 0.8; //Front drive motors are reduced by 20%,
		//to help equalize the weight difference between the front and back of the bot.

		int encoderMax = 130; //Encoder stops arm from moving up at 130 degrees
		int encoderMin = 10; //Encoder stops arm from moving down at 10 degrees


		//Remote Control Commands- DON'T CHANGE! EVER!
		int DFR = vexRT[Ch3] - vexRT[Ch1] - vexRT[Ch4]; //Drive Front Right power movement controls DONT CHANGE!
		int DBR =  vexRT[Ch3] - vexRT[Ch1] + vexRT[Ch4]; //Drive Back Right
		int DFL = vexRT[Ch3] + vexRT[Ch1] + vexRT[Ch4]; //Drive Front Left
		int DBL =  vexRT[Ch3] + vexRT[Ch1] - vexRT[Ch4]; //Drive Front Right

		if(SensorValue[shaftEncoder] > armPowerAngle){ //If the encoder is at higher than the angle it should be boosted at
			armMotorPower = armMotorBoostPower; //Arm motors will move at boost motor power
		}
		if(vexRT[Btn6U]==1 && SensorValue[shaftEncoder] < encoderMax){ //If 6Up is pressed and the encoder isn't past its maximum
			motor[topLeftOut] = armMotorPower; //all arm motors up at arm motor power
			motor[topLeftIn] = armMotorPower;
			motor[topRightIn] = armMotorPower;
			motor[topRightOut] = armMotorPower;
			if(SensorValue[shaftEncoder] > clawClampAngle && SensorValue[shaftEncoder] < clawOpenAngle){
				motor[clawLeft] = clawPower;
				motor[clawRight] = clawPower;
			}
			else if(SensorValue[shaftEncoder] > clawOpenAngle){
				motor[clawLeft] = -clawPower;
				motor[clawRight] = -clawPower;
			}
		}
		else if(vexRT[Btn6D]==1 && SensorValue[shaftEncoder] > encoderMin){ //If 6Down is pressed and the encoder isn't past its minimum
			motor[topLeftOut] = -armMotorPowerDown; //all arm motors down at arm motor power down
			motor[topLeftIn] = -armMotorPowerDown;
			motor[topRightIn] = -armMotorPowerDown;
			motor[topRightOut] = -armMotorPowerDown;
		}
		else if(vexRT[Btn7D]==1 && SensorValue[shaftEncoder] > encoderMin){ //If 7Down is pressed and the encoder isn't past its minimum
			motor[topLeftOut] = -armMotorBoostPower; //all arm motors down at boost power
			motor[topLeftIn] = -armMotorBoostPower;
			motor[topRightIn] = -armMotorBoostPower;
			motor[topRightOut] = -armMotorBoostPower;
		}
		else if(vexRT[Btn5U]==1 && SensorValue[shaftEncoder] < encoderMax && SensorValue[shaftEncoder] > encoderMin){ //If 5Up is pressed
			motor[topLeftOut] = holdPower; //Give arm motors a bit of power to keep it from moving down
			motor[topLeftIn] = holdPower;
			motor[topRightIn] = holdPower;
			motor[topRightOut] = holdPower;
		}
		else if(vexRT[Btn5D]==1 && SensorValue[shaftEncoder] < encoderMax && SensorValue[shaftEncoder] > encoderMin){ //If 5Up is pressed
			motor[topLeftOut] = -holdPower; //Give arm motors a bit of power to keep it from moving down
			motor[topLeftIn] = -holdPower;
			motor[topRightIn] = -holdPower;
			motor[topRightOut] = -holdPower;
		}
		else if(vexRT[Btn8L]==1){
			motor[clawLeft] = armMotorBoostPower;
			motor[clawRight] = armMotorBoostPower;
		}
		else if(vexRT[Btn8R]==1){
			motor[clawLeft] = -armMotorBoostPower;
	    motor[clawRight] = -armMotorBoostPower;
		}
		else{
			motor[topLeftOut] = 0; //If nothing pressed, don't move arm motors
			motor[topLeftIn] = 0;
			motor[topRightIn] = 0;
			motor[topRightOut] = 0;

			motor[clawLeft] = 0;
			motor[clawRight] = 0;
		}


		if(DFR>driveMotorPower){ //If each motor value is above or below the maximum drive motor power, set the motor to the max. or min. drive motor power
			DFR = driveMotorPower; //Just caps each drive motor's power
		}
		else if(DFR<-driveMotorPower){
			DFR = -driveMotorPower;
		}

		if(DBR>driveMotorPower){
			DBR = driveMotorPower;
		}
		else if(DBR<-driveMotorPower){
			DBR = -driveMotorPower;
		}

		if(DFL>driveMotorPower){
			DFL = driveMotorPower;
		}
		else if(DFL<-driveMotorPower){
			DFL = -driveMotorPower;
		}

		if(DBL>driveMotorPower){
			DBL = driveMotorPower;
		}
		else if(DBL<-driveMotorPower){
			DBL = -driveMotorPower;
		}
		DFR = DFR*frontMotorReductionFactor; //Reduces the front motor power by the reduction factor, to help equalize from weight being more over the back wheels
		DFL = DFL*frontMotorReductionFactor;
		motor[driveFrontRight] = DFR; //Set the drive motors to their eventual values
		motor[driveBackRight] =  DBR;
		motor[driveFrontLeft] = DFL;
		motor[driveBackLeft] =  DBL;

	}
}
